package main

import (
	"github.com/bwplotka/mimic"
	"github.com/bwplotka/mimic/encoding"
	"github.com/observatorium/observatorium/configuration_go/kubegen/openshift"
	templatev1 "github.com/openshift/api/template/v1"
	"github.com/rhobs/configuration/clusters"
	"github.com/thanos-community/thanos-operator/config"

	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/utils/ptr"
)

const (
	crdTemplateDir = "bundle"

	// thanosOperatorCRDRef is the commit ref used to sync the Thanos Operator CRDs from upstream thanos community repo.
	// This is generated by mage sync:operator and should not be modified manually in normal circumstances.
	thanosOperatorCRDRef = "5ae5bff31d8b61f8d74a7c66a05a7fc976cb3428"
)

// ThanosOperatorCRDS Generates the CRDs for the Thanos operator.
// This is synced from the latest upstream ref at:
// https://github.com/thanos-community/thanos-operator/tree/main/config/crd/bases
func (b Build) ThanosOperatorCRDS(config clusters.ClusterConfig) error {
	// For rhobss01ue1 and rhobsi01uw2 clusters, CRDs are handled in metrics bundle
	if isMigratedCluster(config) {
		return nil // CRDs are generated as part of metrics bundle
	}
	gen := b.generator(config, "thanos-operator-crds")
	return crds(gen)
}

// CRDS Generates the CRDs for the Thanos operator.
// This is synced from the latest upstream ref at:
// https://github.com/thanos-community/thanos-operator/tree/main/config/crd/bases
func (p Production) CRDS() error {
	return crds(p.generator(crdTemplateDir))
}

// CRDS Generates the CRDs for the Thanos operator.
// This is synced from the latest upstream ref at:
// https://github.com/thanos-community/thanos-operator/tree/main/config/crd/bases
func (s Stage) CRDS() error {
	return crds(s.generator(crdTemplateDir))
}

func crds(gen *mimic.Generator) error {
	const (
		compact   = "thanoscompacts.yaml"
		queries   = "thanosqueries.yaml"
		receivers = "thanosreceives.yaml"
		rulers    = "thanosrulers.yaml"
		stores    = "thanosstores.yaml"
		base      = "https://raw.githubusercontent.com/thanos-community/thanos-operator/" + thanosOperatorCRDRef + "/config/crd/bases/monitoring.thanos.io_"
	)

	var objs []runtime.Object
	for _, component := range []string{compact, queries, receivers, rulers, stores} {
		crd, err := getCustomResourceDefinition(base + component)
		if err != nil {
			return err
		}

		objs = append(objs, crd)
	}

	gen.Add("thanos-operator-crds.yaml", encoding.GhodssYAML(
		openshift.WrapInTemplate(
			objs,
			metav1.ObjectMeta{Name: "thanos-operator-crds"},
			[]templatev1.Parameter{},
		),
	))
	gen.Generate()

	return nil
}

func (b Build) ThanosOperator(config clusters.ClusterConfig) error {
	// For rhobss01ue1 and rhobsi01uw2 clusters, operator is handled in metrics bundle
	if isMigratedCluster(config) {
		return nil // Operator is generated as part of metrics bundle
	}

	gen := b.generator(config, "thanos-operator")

	objs, err := operatorResources(config.Namespace, config.Templates)
	if err != nil {
		return err
	}

	gen.Add("operator.yaml", encoding.GhodssYAML(
		openshift.WrapInTemplate(objs, metav1.ObjectMeta{Name: "thanos-operator-manager"}, []templatev1.Parameter{}),
	))

	gen.Generate()
	return nil
}

// Operator Generates the Thanos Operator Manager resources.
func (p Production) Operator() error {
	gen := p.generator("operator")
	templates := clusters.ProductionMaps
	return operator(p.namespace(), gen, templates)
}

// Operator Generates the Thanos Operator Manager resources.
func (s Stage) Operator() error {
	gen := s.generator("operator")
	templates := clusters.StageMaps
	return operator(s.namespace(), gen, templates)
}

func operator(namespace string, gen *mimic.Generator, m clusters.TemplateMaps) error {
	objs, err := operatorResources(namespace, m)
	if err != nil {
		return err
	}
	gen.Add("operator.yaml", encoding.GhodssYAML(
		openshift.WrapInTemplate(
			objs,
			metav1.ObjectMeta{Name: "thanos-operator-manager"},
			[]templatev1.Parameter{},
		),
	))

	gen.Generate()
	return nil
}

func operatorResources(namespace string, m clusters.TemplateMaps) ([]runtime.Object, error) {
	const (
		// thanosOperatorRBACBase is the base URL for fetching RBAC resources from upstream.
		thanosOperatorRBACBase = "https://raw.githubusercontent.com/thanos-community/thanos-operator/" + thanosOperatorCRDRef + "/config/rbac/"
	)
	config.SetGlobalPrefix("thanos-operator-")
	config.SetGlobalNamespace(namespace)
	config.SetGlobalCommonLabels("thanos-operator", "thanos-operator", "rhobs")
	config.SetGlobalManagerImage(clusters.TemplateFn(clusters.ThanosOperator, m.Images))
	config.SetGlobalAuthProxyImage(clusters.TemplateFn(clusters.KubeRbacProxy, m.Images))

	deployment := config.ControllerManagerDeployment(config.WithAuthProxy(), config.WithPrometheusRule())
	deployment.Spec.Template.Spec.Volumes = []corev1.Volume{
		{
			Name: "tls",
			VolumeSource: corev1.VolumeSource{
				Secret: &corev1.SecretVolumeSource{
					SecretName:  "kube-rbac-proxy-tls",
					DefaultMode: ptr.To(int32(420)),
					Optional:    ptr.To(false),
				},
			},
		},
		{
			Name: "service-ca",
			VolumeSource: corev1.VolumeSource{
				ConfigMap: &corev1.ConfigMapVolumeSource{
					LocalObjectReference: corev1.LocalObjectReference{
						Name: "openshift-service-ca.crt",
					},
					DefaultMode: ptr.To(int32(420)),
					Optional:    ptr.To(false),
				},
			},
		},
		{
			Name: "config",
			VolumeSource: corev1.VolumeSource{
				ConfigMap: &corev1.ConfigMapVolumeSource{
					LocalObjectReference: corev1.LocalObjectReference{
						Name: "thanos-operator-rbac-config",
					},
					DefaultMode: ptr.To(int32(420)),
					Optional:    ptr.To(false),
				},
			},
		},
	}

	for i, container := range deployment.Spec.Template.Spec.Containers {
		if container.Name == "manager" {
			deployment.Spec.Template.Spec.Containers[i].Resources = clusters.TemplateFn(clusters.Manager, m.ResourceRequirements)
		}
		if container.Name == "kube-rbac-proxy" {
			deployment.Spec.Template.Spec.Containers[i].VolumeMounts = []corev1.VolumeMount{
				{
					Name:      "tls",
					MountPath: "/etc/tls/private",
					ReadOnly:  true,
				},
				{
					Name:      "service-ca",
					MountPath: "/etc/service-ca",
					ReadOnly:  true,
				},
				{
					Name:      "config",
					MountPath: "/etc/config",
					ReadOnly:  true,
				},
			}
			deployment.Spec.Template.Spec.Containers[i].Resources = clusters.TemplateFn(clusters.KubeRbacProxy, m.ResourceRequirements)
			deployment.Spec.Template.Spec.Containers[i].Args = []string{
				"--secure-listen-address=0.0.0.0:8443",
				"--upstream=http://127.0.0.1:8080/",
				"--v=4",
				"--tls-cert-file=/etc/tls/private/tls.crt",
				"--tls-private-key-file=/etc/tls/private/tls.key",
				"--client-ca-file=/etc/service-ca/service-ca.crt",
				"--config-file=/etc/config/config.yaml",
			}
		}
	}

	// Fetch Manager ClusterRole from upstream
	managerRole, err := getClusterRole(thanosOperatorRBACBase + "role.yaml")
	if err != nil {
		return nil, err
	}
	// Override name and labels for our deployment
	managerRole.ObjectMeta.Name = "thanos-operator-manager-role"
	managerRole.ObjectMeta.Labels = map[string]string{
		"app.kubernetes.io/component":                  "rbac",
		"app.kubernetes.io/created-by":                 "thanos-operator",
		"app.kubernetes.io/instance":                   "manager-role",
		"app.kubernetes.io/managed-by":                 "rhobs",
		"app.kubernetes.io/name":                       "clusterrole",
		"app.kubernetes.io/part-of":                    "thanos-operator",
		"rbac.authorization.k8s.io/aggregate-to-admin": "true",
	}

	objs := []runtime.Object{
		deployment,
		managerRole,
		config.ManagerServiceAccount(),
		config.LeaderElectionRole(),
		config.AuthProxyClusterRole(),
		config.LeaderElectionRoleBinding(),
		config.ManagerClusterRoleBinding(),
		config.AuthProxyClusterRoleBinding(),
	}
	for _, cm := range operatorServingCertConfigMaps(namespace) {
		objs = append(objs, cm)
	}

	for _, crd := range config.CRDList {
		viewer := config.CRDViewerClusterRole(crd)
		viewer.ObjectMeta.Labels["rbac.authorization.k8s.io/aggregate-to-view"] = "true"
		objs = append(objs, viewer)
		editor := config.CRDEditorClusterRole(crd)
		editor.ObjectMeta.Labels["rbac.authorization.k8s.io/aggregate-to-edit"] = "true"
		objs = append(objs, editor)
	}

	metricsReader := config.AuthProxyClientClusterRole()
	metricsReader.ObjectMeta.Labels["rbac.authorization.k8s.io/aggregate-to-view"] = "true"
	objs = append(objs, metricsReader)

	service := config.AuthProxyService()
	service.ObjectMeta.Annotations = map[string]string{
		"service.beta.openshift.io/serving-cert-secret-name": "kube-rbac-proxy-tls",
	}
	objs = append(objs, service)

	return objs, nil
}

func operatorServingCertConfigMaps(namespace string) []*corev1.ConfigMap {
	labels := map[string]string{
		"app.kubernetes.io/component":  "manager",
		"app.kubernetes.io/created-by": "thanos-operator",
		"app.kubernetes.io/instance":   "controller-manager",
		"app.kubernetes.io/managed-by": "rhobs",
		"app.kubernetes.io/name":       "configmap",
		"app.kubernetes.io/part-of":    "thanos-operator",
	}

	serviceCert := &corev1.ConfigMap{
		TypeMeta: metav1.TypeMeta{
			APIVersion: "v1",
			Kind:       "ConfigMap",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name:      "thanos-operator-serving-cert",
			Namespace: namespace,
			Labels:    labels,
			Annotations: map[string]string{
				"service.beta.openshift.io/inject-cabundle": "true",
			},
		},
		Data: map[string]string{},
	}

	rbacConfig := &corev1.ConfigMap{
		TypeMeta: metav1.TypeMeta{
			APIVersion: "v1",
			Kind:       "ConfigMap",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name:      "thanos-operator-rbac-config",
			Namespace: namespace,
			Labels:    labels,
		},
		Data: map[string]string{
			"config.yaml": `"authorization":
  "static":
  - "path": "/metrics"
    "resourceRequest": false
    "user":
      "name": "system:serviceaccount:openshift-customer-monitoring:prometheus-k8s"
    "verb": "get"`,
		},
	}
	return []*corev1.ConfigMap{serviceCert, rbacConfig}
}
